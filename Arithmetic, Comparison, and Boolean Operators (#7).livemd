# Arithmetic, Comparison, and Boolean Operators (#7)

## 도입부

> 엘릭서의 산술, 비교, 부울 연산자를 살펴봅니다.

이번에는 프로그래밍 언어를 사용하기 위한 필수 연산자에 대해 배울 것입니다. 많은 언어에서 비슷한 연산자를 배웠기 때문에, 새로운 언어를 배울 때 이 부분은 필수지만 지루한 것 같습니다. 다행히도 여기에는 어려움이나 독특한 것들이 적습니다. 엘릭서만의 몇 가지 독특한 특징들도 있지만, 대부분 이 연산자들은 제가 사용했던 다른 언어들과 비슷합니다.

## 산술 연산자

산술 연산자는 기본적인 수학 연산자입니다.

덧셈, 뺄셈, 곱셈, 나눗셈(`+`, `-`, `*`, `/`)이 있습니다. 이 연산자들은 자바스크립트, C# 혹은 제가 사용한 대부분 언어와 같습니다. 다른 수학적 연산자는 없습니다. 자바스크립트와 C#에서 많이 쓰이는 증감 연산자도 없습니다. 다른 수학 연산은 모두 함수를 통해 수행해야 합니다.

IEx에서 몇 가지 예제를 살펴보겠습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> 6 + 3
9
iex> 6 - 3
3
iex> 6 * 3
18
iex> 6 / 3
2.0
```

연산 순서는 제가 본 다른 프로그래밍 언어와 같습니다. 자바스트립트나 C#처럼 괄호를 사용하면 연산 순서를 재정의하거나 그룹화를 하여 연산을 읽기 쉽게 할 수 있습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> 4 + 3 * 5
19
iex> (4 + 3) * 5
35
```

엘릭서에서 나눗셈 연산자(/)를 사용하는 나눗셈은 피연산자가 정수든 부동 소수이든 상관없이 항상 부동 소수가 됩니다. 그래서 5 / 2 는 2.5이고, 8 / 2 는 4.0입니다. 자바스트립트는 비슷하게 동작하지만, 자바스크립트는 단일 숫자 타입을 가지고 있습니다. C#은 이에 해당하지 않습니다. C#에서 두 정수를 나눈 결과는 정수가 됩니다. 엘릭서에서 정수 나눗셈을 하려면 `div` 함수를 통해 정수 나눗셈을 할 수 있습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> 5 / 2
2.5
iex> div(5, 2)
2
iex> 8 / 2
4.0
iex> div(8, 2)
4
```

엘릭서에는 자바스트립트나 C#처럼 모듈로 연산자가 없습니다. `rem` 함수를 사용하여 같은 작업을 수행할 수 있습니다.

아래는 C#이나 자바스크립트의 `5 % 2` 와 `28 % 10` 에 해당합니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> rem(5, 2)
1
iex> rem(28, 10)
8
```

`rem/2` 함수와 다른 언어의 일반적인 모듈로 연산은 한 가지 차이점이 있습니다. 결과가 0이 아닌 한 결과의 부호는 첫 번째 인자의 부호와 같습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> rem(-10, 10)
0
iex> rem(-10, 12)
-10
iex> rem(10, 12)
10
iex> rem(-100, 12)
-4
```

## 비교 연산자

비교 연산자도 C#과 자바스크립트의 연산자와 매우 유사하지만, 몇 가지 차이점이 있습니다.

### 동등성

자바스크립트와 마찬가지로 엘릭서는 이중 등호(`==`)와 삼중 등호(`===`) 비교 연산자가 있습니다. 자바스크립트처럼 삼중 등호가 이중 등호보다 엄격하지만, 자바스크립트와는 다르게 엄격함의 차이가 작습니다.

삼중 등호 연산자(`===`)는 비교 대상인 두 항목의 유형이 같은지와 유형이 같다면 정확하게 같은 값인지 테스트합니다. 몇 가지 예를 살펴보겠습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> "Bob" === 4
false
iex> 4 === 4
true
iex> "Bob" === "Bob"
true
iex> 4.0 === 4
false
iex> true === "true"
false
iex> 3.5 === :cheese
false
iex> :chees === :cheese
false
iex> :cheese === :cheese
true
```

네, 아톰의 이름이 다르면 완전히 다른 두 개의 아톰이라는 것을 보여주기 위해 철자가 틀린 `:chees`를 두었습니다.

이중 등호 연산자 (`==`)는 거의 똑같습니다. 차이점은 오직 부동 소수점과 정수를 서로 비교할 수 있도록 강제한다는 점입니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> 5 === 5.0
false
iex> 5 == 5.0
true
iex> 5 == 5.000000001
false
iex> "true" == true
false
iex> 1 == true
false
iex> 0 == false
false
```

자바스크립트처럼 모든 규칙을 기억해야 하는 복잡한 일은 없습니다. 부동 소수점과 정수가 같은 수를 나타내는 경우 두 값이 같을 수 있다는 것을 허용하기만 하면 됩니다.

반면에 C#은 정적 타입 언어이므로 정확하게 비교하는 것을 특별히 구현한 메소드가 없는 한 서로 다른 데이터 타입은 비교할 수 없습니다. 이것이 정적 타입 언어와 동적 타입 언어의 차이점입니다.

같지 않은 연산자 `!=`의 반대는 `==`가 있고, `!==`의 반대는 `===`가 있습니다. 이러한 연산자는 자바스크립트의 동등 연산자와 비슷하게 생겼습니다.

따라서 자바스크립트와 다르게 기대하지 않은 타입 변환을 방지하기 위해 엄격한 동등 연산자를 사용할 필요는 없을 것 같습니다. 부동 소수점과 정수를 구분해야 하는 경우가 아니라면 기본적으로 이중 등호 `==` 사용을 추천합니다.

지금까지 살펴본 바로는 C#이나 자바스크립트처럼 같은 데이터의 다른 인스턴스를 비교하는 것에 대해서는 걱정할 필요가 없습니다. C#이나 자바스크립트의 객체는 비교를 수행하는 코드가 포함된 특수한 `동등` 메서드를 구현하지 않는 한 같은 데이터를 포함하는 다른 객체와 같을 수 없습니다(적어도 C#에서는).

엘릭서에서 이 문제를 구체적으로 다룬 내용이 없어서 몇 가지 실험을 해보았습니다. 실험 결과, 데이터 구조는 항상 같은 데이터 구조와 동등하다는 것을 발견했습니다.

서로 다른 시간에 서로 다른 장소에서 생성된 같은 데이터 구조는 엘릭서 내부에서 완전히 같은 데이터에 대한 참조일 뿐이라고 생각합니다. 이것이 사실이라는 내용을 읽지는 못했지만 엘릭서의 모든 데이터는 불면이므로 완벽하게 말이 될 것입니다. 이 언어는 같은 인스턴스 데이터가 수정되는 것에 대해 걱정할 필요가 없으므로 같은 데이터의 복사본을 여러 개 저장할 필요가 없습니다.

이는 C#에서 문자열이 동작하는 방식과 유사합니다. 사용 중인 모든 문자열이 담긴 테이블이 있고, 동일한 문자열을 참조하는 모든 변수는 동일한 문자열 인스턴스를 가리킵니다. 널리 알려지지는 않았지만 C#의 문자열은 실제로 불변입니다. 모든 문자열 연산은 새로운 문자열 인스턴스를 생성합니다. 이러한 불변성은 동일한 문자열의 인스턴스가 두 개가 되지 않기 때문에 메모리를 절약할 수 있습니다. 문자열뿐만 아니라 모든 데이터에 적용된다는 점을 제외하면 엘릭서의 동작 방식과 같습니다.
