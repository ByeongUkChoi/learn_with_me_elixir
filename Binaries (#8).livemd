# Binaries (#8)

## 도입부

엘릭서의 데이터 타입을 설명하는 글에서는 바이너리를 간략하게 다루었지만, 여기서는 더 자세히 설명합니다.

앞에서 언급했듯이 바이너리는 바이너리 데이터를 바이트 모음(binary) 또는 비트 모음(bitstring)으로 저장합니다. 표면적으로는 두 가지가 거의 동일하다고 생각하지만, 바이너리를 사용하면 바이트를 가장 작은 요소로 하는 데이터를 더 간단하게 처리할 수 있습니다.

바이너리 리터럴은 꺽쇠 괄호`<<>>`로 표현할 수 있으며, 그 안의 숫자는 단일 바이트의 값을 나타냅니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> <<1, 0, 4, 18>>
<<1, 0, 4, 18>>
```

따라서 바이너리 리터럴 `<<1, 0, 4, 18>>`은 0x01, 0x00, 0x04, 0x12 값을 가진 4바이트를 나타냅니다.

바이트 0에서 255 사이의 값만 저장할 수 있으므로 255를 초과하는 바이트 값은 의미가 없습니다. 255를 초과하는 값을 지정하면 어떻게 되는지 확인해 보았는데, 주행 거리계처럼 값이 0으로 돌아오고 거기서부터 올라가는 것을 확인할 수 있었습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> <<1, 2, 255, 256>>
<<1, 2, 255, 0>>
iex> <<1, 2, 255, 260>>
<<1, 2, 255, 4>>
```

바이트 값은 10진수 8진수(0o) 또는 16진수(0x) 표기법을 사용하여 지정할 수 있습니다. 다음은 예시입니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> <<1, 0, 0o04, 0x12>>
<<1, 0, 4, 18>>
```

IEx는 항상 10진수 바이트 값을 사용하여 바이너리 값을 표시합니다.

바이너리는 `<>` 연산자를 사용하여 연결할 수 있습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> <<3, 12>> <> <<4, 8>>
<<3, 12, 4, 8>>
```

`byte_size` 함수는 바이너리 값의 바이트 수를 검색하는 데 사용할 수 있습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> byte_size(<<1, 0, 4, 18>>)
4
iex> byte_size(<<1, 2, 128, 96, 255, 4>>)
6
```

변수를 사용하여 바이너리 리터럴로 바이트 값을 지정할 수도 있습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> byte1 = 34
34
iex> byte2 = 154
154
iex> binary = <<byte1, byte2, 87>>
<<34, 154, 87>>
```

## 비트스트링

비트스트링은 바이트 대신 비트 모음으로 동작한다는 점을 제외하면 매우 유사합니다. 비트스트링 리터럴은 거의 동일하게 보입니다. 전체 바이트는 10진수(혹은 8진수 혹은 16진수)로 지정할 수 있으며, 비트 시퀀스는 `::size` 연산자를 사용하여 지정할 수 있습니다. 따라서 `<<2::size(2)>>`는 비트 문자열 "10", `<<5::size(3)>>`는 비트 문자열 "101"이 됩니다. 더 긴 비트 시퀀스를 지정하기 위해 높은 숫자를 사용할 수도 있습니다. 비트 문자열 `<<1138::size(11)>>`은 `10001110010`과 같습니다.

IEx에서 비트스트림 리터럴이 어떻게 보이는지 살펴보겠습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> <<2::size(2)>>
<<2::size(2)>>
iex> <<5::size(3)>>
<<5::size(3)>>
iex> <<1138::size(11)>>
<<142, 2::size(3)>>
```

마지막 예제인 `<<1138::size(11)>>`를 살펴 겠습니다. IEx에서는 `<<142, 2::size(3)>>`로 표시됩니다. 이 두 값은 서로 다른 방식으로 표시될 뿐 동일합니다. `142`는 앞 8비트인 `10001110`에 해당하며, `2::size(3)`은 나무지 3비트인 `010`에 해당합니다.

따라서 IEx는 항상 8비트의 모든 청크에 대해 바이트 값을 표시하고 `::size` 표기법을 사용하여 나머지 비트를 표시하는 것을 볼 수 있습니다.
