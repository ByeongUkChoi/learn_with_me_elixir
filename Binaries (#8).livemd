# Binaries (#8)

## 도입부

엘릭서의 데이터 타입을 설명하는 글에서는 바이너리를 간략하게 다루었지만, 여기서는 더 자세히 설명합니다.

앞에서 언급했듯이 바이너리는 바이너리 데이터를 바이트 모음(binary) 또는 비트 모음(bitstring)으로 저장합니다. 표면적으로는 두 가지가 거의 동일하다고 생각하지만, 바이너리를 사용하면 바이트를 가장 작은 요소로 하는 데이터를 더 간단하게 처리할 수 있습니다.

바이너리 리터럴은 꺽쇠 괄호`<<>>`로 표현할 수 있으며, 그 안의 숫자는 단일 바이트의 값을 나타냅니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> <<1, 0, 4, 18>>
<<1, 0, 4, 18>>
```

따라서 바이너리 리터럴 `<<1, 0, 4, 18>>`은 0x01, 0x00, 0x04, 0x12 값을 가진 4바이트를 나타냅니다.

바이트 0에서 255 사이의 값만 저장할 수 있으므로 255를 초과하는 바이트 값은 의미가 없습니다. 255를 초과하는 값을 지정하면 어떻게 되는지 확인해 보았는데, 주행 거리계처럼 값이 0으로 돌아오고 거기서부터 올라가는 것을 확인할 수 있었습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> <<1, 2, 255, 256>>
<<1, 2, 255, 0>>
iex> <<1, 2, 255, 260>>
<<1, 2, 255, 4>>
```

바이트 값은 10진수 8진수(0o) 또는 16진수(0x) 표기법을 사용하여 지정할 수 있습니다. 다음은 예시입니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> <<1, 0, 0o04, 0x12>>
<<1, 0, 4, 18>>
```

IEx는 항상 10진수 바이트 값을 사용하여 바이너리 값을 표시합니다.

바이너리는 `<>` 연산자를 사용하여 연결할 수 있습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> <<3, 12>> <> <<4, 8>>
<<3, 12, 4, 8>>
```

`byte_size` 함수는 바이너리 값의 바이트 수를 검색하는 데 사용할 수 있습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> byte_size(<<1, 0, 4, 18>>)
4
iex> byte_size(<<1, 2, 128, 96, 255, 4>>)
6
```

변수를 사용하여 바이너리 리터럴로 바이트 값을 지정할 수도 있습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> byte1 = 34
34
iex> byte2 = 154
154
iex> binary = <<byte1, byte2, 87>>
<<34, 154, 87>>
```
