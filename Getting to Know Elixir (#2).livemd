# Getting to Know Elixir (#2)

## 도입부

엘릭서로 뛰어들기 전에, 좀 더 자세히 알아봅시다. 언어에 대해 아는 것은 그것이 어디에서 왔고 무엇을 할 수 있는지에 대하여 더 나은 생각을 갖게 주도록 하여 좋습니다.

저는 언어를 배우기 전에, 장단점을 배우는 것 뿐만 아니라 그것으로 무엇을 할 수 있는지 읽는 것을 좋아합니다. 그것은 저에게 그 언어가 어디에 그리고 언제 써야 하는지 도와줍니다.

## 엘릭서의 특성

엘릭서는 파이썬과 자바스크립트같이 동적 타이핑 언어입니다. 이것은 데이터 타입이 컴파일 타임이 아니라 런타임에 결정된다는 것을 뜻합니다. 한 변수는 어떤 지점에서는 문자열을 참조할 수 있고, 그 후에는 정수를 참조할 수 있습니다. 이것은 컴파일 타임에 엄격하게 알아야하 는 정적 타입 언어인 자바와 C#같은 언어와는 대조적입니다. 정적 타입 언어에서 변수는 항상 같은 타입이어야만 하고 다른 타입을 가질 수 없습니다.

이런 트레이드오프는 유연성과 이른 에러 감지의 사이에 있습니다. 정적 타입 언어는 컴파일 타임에 타입 관련된 에러를 잡을 수 있고 해당 타입 정보로 효율적인 코드 컴파일을 할 수 있지만, 코드의 유연성은 더 떨어집니다.

엘릭서는 함수형입니다. 함수형 언어는 일급 시민 함수로 되어있고 선언형 프로그래밍인 경향이 있는데, 어떻게 할 것인지 보다 무엇을 할 것인지에 초점을 맞춰야 하는 경향이 있다. 함수는 작고 단순한 경향이 있으며, 작은 함수들을 조립해서 더 큰 함수를 만듭니다. 또한 함수형 언어는 불변형 데이터를 사용하는 경향이 있습니다. 이 시점에서 저는 함수형 언어의 전문가는 아니지만, 향후 글에서 함수형 프로그래밍의 이해한 내용을 계속해서 살펴보겠습니다. 이것은 명령형 프로그래밍과는 다른 사고방식을 가져야 하고, 제가 아직 완전히 익히지 못한 부분입니다. 연습하고 함수형 예제 코드를 찾는 것은 아마 더 잘하기 위한 열쇠일 것입니다.

엘릭서 언어는 확장과 유지 보수가 가능한 애플리케이션을 만드는 것을 지향합니다. 엘릭서는 매우 이 원칙들을 강조합니다. 그리고 저는 언어를 배우면서 이러한 언어의 측면을 더 잘 이해하기를 바랍니다.

## 엘릭서 플랫폼

엘릭서에게는 언어 그 이상의 훨씬 더 많은 것이 있기 때문에 제가 "엘릭서 언어"라는 용어를 사용했습니다. 그것에는 실행되는 플랫폼과 주변 생태계가 있습니다. 자바, 스칼라, 클로저가 JVM 바이트 코드로 컴파일하여 자바 가상 머신(VM)에서 실행되고, C#, VB.NET, F#이 IL(중간 어셈블리) 바이트 코드로 컴파일되고 .NET언어를 위한 VM인 공용 언어 런타임에서 실행되는 것처럼, 엘릭서도 또한 바이트 코드로 컴파일되며 가상 머신에서 실행됩니다.

엘릭서가 실행되는 가상 머신은 엘릭서를 위해 만들어진 가상 머신이 아니고, 얼랭VM(혹은 BEAM)이라고 불리는 이미 존재하는 가상 머신 입니다. 이것의 공식적인 이름은 BEAM이지만, 이것이 얼랭VM으로 더 자주 불리는 것을 보았기 때문에 저는 여기서 그렇게 부르도록 하겠습니다. 얼랭은 확장 가능하고 동시에 실행할 수 있으며 견고한 코드가 가능한 플랫폼에서 실행되는 오래된(1980년대 중반부터 시작된) 언어입니다. 그래서 엘릭서는 모든 것을 새롭게 만드는 대신, 기존에 존재하는 플랫폼에 통합하였습니다.

## 동시성과 확정성 그리고 견고함

제가 아직 엘릭서를 배우지 않았음에도, 왜 사람들이 엘릭서를 그렇게나 좋아하는지 알아보았을 때, 엘릭서가 어떻게 동시성, 확장성 그리고 견고함을 갖는지 알게 되었습니다.

무엇보다 엘릭서의 함수형 특징과 불변 데이터는 수많은 동시성 문제를 피하는 것을 의미합니다. 가변, 공유 상태 그리고 사이드 이펙트는 진심으로 멀티 스레드 프로그래밍에서 골칫거리입니다. 이것은 그 자체로 큰 주제이며 저는 아마도 이것에 대해 자세하게 파지 않을 것입니다. 함수형 프로그래밍에 대한 이 [기사](https://www.miles.no/blogg/tema/teknisk/why-care-about-functional-programming-part-1-immutability)는 이 주제에 대해 다루고 있으므로, 더 배우고 싶으시다면 읽어보십시오.

제가 [이전 글](https://github.com/ByeongUkChoi/learn_with_me_elixir/blob/main/An%20Introduction%20(%231).livemd)에서 설명했듯이, 엘릭서는 액터 모델의 구현을 통해 확장 가능한 동시성을 달성합니다. 엘릭서의 액터는 매우 가벼운 프로세스(운영체제의 프로세스가 아닌 가상 머신의 가상 프로세스)로 매우 적은 메모리를 사용합니다. 수십만 개 혹은 심지어 수백만 개의 이들이 얼랭VM에서 실행될 수 있어서, 많은 부하에서도 애플리케이션과 서비스가 계속 작동할 수 있습니다. 또한 이 모든 프로세스는 서로 독립적으로 실행되므로, 매우 높은 수준의 동시성을 가집니다.

프로세스 간의 통신은 불변 데이터를 포함하는 메세지를 통해 이루어집니다. 이것은 가변 데이터, 공유 상태, 잠금, 경쟁 상태 그리고 다른 언어에서 동시성 프로그래밍을 할 때 겪는 모든 문제에 대해 걱정하지 않도록 해줍니다.

엘릭서는 동일한 머신 뿐만 아니라 여러 머신에서 동시성 처리를 쉽게 할 수 있도록 하여 분산 시스템을 쉽게 만들 수 있습니다. 엘릭서 프로세스는 동일한 머신에서처럼 쉽게 다른 머신에서 돌아가는 엘릭서 프로세스에 메세지를 보낼 수 있습니다. 제가 알기로는 두 대의 머신에서 수백 대의 머신으로 확장하는 것은 비교적 간단합니다(진심으로 믿기 위해 이것을 보고 싶긴 하지만).

견고함은 슈퍼바이저라고 불리는 것에 의해 갖출 수 있습니다. 저는 이 부분에서 매우 조금밖에 알지 못하지만, 엘릭서에 대해 읽어본 것에 따르면, 이것들은 엘릭서 프로세스들을 모니터링하고 그들이 충돌 시 재시작을 할 수 있습니다. 사실 이것은 엘릭서 프로세스들을 매우 견고하게 해줍니다. 제가 이해한 바로는 프로세스들은 때때로 오류가 발생하면 의도적으로 스스로 충돌이 나도록 하고, 그것들이 되살아날 것이라고 알고 있습니다. 죽지 않는 것은 몇 가지 흥미로운 결과를 초래할 수 있습니다. 여러분은 다시 살아나리라는 것을 안다면 죽는 것을 덜 두려워할 것입니다. 저는 엘릭서의 이러한 측면을 배우는 것에 대해 정말 알고 싶지만, 이것은 제가 훨씬 나중에 배울 심화 기능이라고 생각합니다. 저희는 기초들을 먼저 숙달해야 합니다.
