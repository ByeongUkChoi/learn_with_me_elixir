# Modules and Functions: Part 1 (#10)

## 도입부

> 엘릭서 모듈과 함수에 대해 알아봅시다.

엘릭서의 함수는 예상대로 매개변수와 반환 값을 사용할 수 있지만, 엘릭서는 함수형 언어이므로 함수를 중심으로 언어가 구성되어 있습니다.

엘릭서의 일반적인 함수는 짧고 단순하며 쉽게 테스트할 수 있습니다. 그런 단순한 함수가 서로 결합하여 다른 함수를 만드는 식으로 구성됩니다. 함수를 작고 단순하게 유지하고 다른 작고 단순한 함수를 호출함으로써 엘릭서 프로그램은 이해하기 쉽고 (그리고 마찬가지로 중요한 것은) 테스트를 작성하기 쉬운 경향이 있습니다.

함수는 일급 시민으로, 다른 데이터 변수와 마찬가지로 다른 함수에 전달하고 반환할 수 있습니다. 자바스크립트에는 처음부터 일급 함수의 개념이 있었지만, 변수에 함수를 할당하고 함수를 전달하고 반환하는 것은 최근에 C#에 추가된 기능입니다.

C#에서 함수 매개변수는 다른 모든 것과 마찬가지로 항상 정적으로 타입이 지정되며, 자바스크립트에서는 매개변수와 연결된 타입이 없습니다. 엘릭서 함수 매개변수는 자바스크립트처럼 동적으로 타입이 지정되며, 각 매개변수의 타입은 코드에 선언되지 않습니다.

함수는 일반적으로 모듈에 존재하며, 이것이 엘릭서에서 함수가 그룹화되는 방식입니다.

## 엘릭서 소스 파일

여기서부터는 .exs 와 .ex 로 끝나는 엘릭서 소스 코드 파일을 사용하기 시작합니다. 현재 저는 .ex 엘릭서 소스 코드 파일을 빌드하는 방법을 모르기 때문에, IEx에 로드하고 인터프리트할 수 있는 .exs 파일을 사용하겠습니다.

따라서 앞으로 나올 예제 중 일부는 엘릭서 소스 코드 파일에서 가져온 것이고 나머지는 제가 IEx에 입력한 내용에서 가져온 것입니다. "IEx>" 프롬프트의 유무로 구분할 수 있습니다.

## 모듈

모듈은 엘릭서에서 함수를 캡슐화하고 구성합니다. 객체 지향 언어는 일반적으로 데이터와 해당 데이터가 작동하는 함수가 포함되어 있지만, 엘릭서는 함수와 데이터가 분리되어 있습니다.

관련된 함수들은 모듈에 함께 그룹화됩니다. 동일한 데이터 구조에서 작동하는 함수는 일반적으로 자체 모듈에 함께 있습니다. 예를 들어 엘릭서 표준 라이브러리의 모든 문자열 조작 함수는 `String` 모듈에 함께 그룹화되어 있고, 리스트와 관련된 모든 함수는 `List` 모듈에 있습니다.

모듈을 정의하는데 필요한 구문을 살펴봅시다. 모듈은 `defmodule` 키워드와 모듈 내용을 `do`와 `end` 사이에 넣어 정의합니다.

모듈은 IEx에서 인라인으로 정의할 수 있지만, 그렇게 하는 것은 매우 지저분하고 번거롭습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> defmodule ExampleModule do
...> end

{:module, ExampleModule,
 <<70, 79, 82, 49, 0, 0, 3, 36, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 127,
   0, 0, 0, 12, 20, 69, 108, 105, 120, 105, 114, 46, 69, 120, 97, 109, 112, 108,
   101, 77, 111, 100, 117, 108, 101, 8, 95, ...>>, nil}
```

대신에 모듈은 일반적으로 소스 코드 파일에 정의됩니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule ExampleModule do
  
end
```

그러면 이 "ExampleModule"이란 이름의 모듈의 본문은 `do` 키워드로 시작하여 `end` 키워드로 끝납니다.

모듈의 네임스페이스는 "[namespace2].[module]" 또는 "[namespace1].[namespace2].[module]"로 지정할 수도 있습니다. 이렇게 하면 이름이 같은 모듈이 서로 다른 네임스페이스에 있을 수 있습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule Cars.Driving do
  
end
```

혹은

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule Vehicles.Cars.Driving do
  
end
```

이것은 다음과 같습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule Cars do
  defmodule Driving do
  
  end
end
```

모듈은 단일파일에 정의해야 하며, 여러 소스 코드 파일에 나눌 수 없습니다. 그러나 단일 파일에 여러 모듈을 정의할 수는 있습니다.

흥미로운 사실: 모듈 이름은 내부적으로(Erlang VM에서) 아톰으로 변환되고 그 앞에 "Elixir"가 추가됩니다. 따라서 `Stuff` 모듈은 실제로 내부적으로 `":Elixir.Stuff"`로 표시됩니다. (아톰에 공백이나 점 같은 특수문자가 포함될 때는 앞뒤로 따옴표를 붙여야 합니다.)

제가 본 몇 가지 예제에서 얼랭 모듈 이름도 아톰으로 되어있으며, 얼랭 VM이 모듈에 아톰이 필요하기 때문에 엘릭서가 이렇게 되어있는 것으로 생각됩니다. 모듈 이름 앞에 "Elixir"가 붙기 때문에 얼랭 VM을 모니터링하는 사람 누구나 어떤 모듈이 엘릭서 환경에서 제공되는지 확인할 수 있습니다.

## 기명 함수

엘릭서 함수는 일반적으로 이름이 지정되며, 이를 "기명 함수"라고 합니다. 함수는 `def` 키워드와 매개변수 리스트로 정의됩니다. 함수에는 함수의 내용을 포함하는 본문도 있습니다. 모듈과 마찬가지로 함수 본문은 `do` 키워드로 시작하고 `end` 키워드로 끝납니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule ExampleModule do
  def do_something(parameter1, parameter2) do
    
  end
end
```

위의 예제는 `ExampleModule` 모듈에서 `do_something` 함수를 정의합니다. 이 함수는 두 개의 매개변수 `parameter1`과 `parameter`를 받습니다. 함수 본문에 아무것도 넣지 않았기 때문에 아무것도 반환하지 않습니다.

함수의 마지막 표현식의 값은 함수에서 반환되는 값입니다. 두 숫자를 더하는 예제 함수를 살펴보겠습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
def sum(num1, num2) do
    num1 + num2
end
```

C#과 자바스크립트와는 다르게 `return` 키워드가 필요하지 않습니다. 마지막 구문의 값이 자동으로 함수에서 반환됩니다.

전달된 매개변수를 반환하는 함수를 정의할 수 있습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
def echo(parameter) do
    parameter
end
```

기명 함수는 항상 모듈의 컨텍스트에서 정의해야 합니다! 기명 함수는 모듈 외부에 존재할 수 없습니다.

### 단일행 함수

함수가 매우 간단하고 한 줄로만 구성된 경우 더 간결한 구문을 사용할 수 있습니다. 더 간결한 구문을 사용하여 `substract` 함수를 작성해 보겠습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
def subtract(num1, num2), do: num1 - num2
```

쉼표는 함수 이름과 매개변수를 본문에서 구분하며, 엘릭서가 한 줄로 된 함수 본문을 예상하도록 알려줍니다.

### 함수 이름

엘릭서에서 기명 함수는 이름과 해당 함수의 애리티로 지정됩니다. 애리티는 함수형 프로그래밍에서 많이 사용되는 용어입니다. 간단히 말해서, 함수의 애리티는 허용되는 매개변수의 수입니다. 따라서 위에 나온 `sum` 함수는 2개의 파라미터를 받아들이기 때문에 애리티가 2입니다.
