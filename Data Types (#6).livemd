# Data Types (#6)

## 도입부

대부분의 언어처럼 엘릭서도 데이터 타입이 있습니다. 그렇게 많지는 않습니다. 더 간단한 데이터 타입을 즉시 활용할 수 있지만, 복잡한 데이터 타입은 나중에 그것들의 문서가 필요합니다.

## 기본 타입

이 데이터 타입들은 제가 기본 데이터 타입이라고 부르는 것입니다. 저만의 용어이며 엘릭서의 용어가 아닙니다.

### 정수

엘릭서에서 정수는 다른 언어의 정수와 유사합니다. 소수점이 없는 정수입니다. 정수 리터럴은 단지 숫자라는 점에서 제가 본 모든 언어의 거의 유사합니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> integer1 = 300
300
iex> integer2 = 4
4
iex> integer3 = -34
-34
iex> bigger_integer = 745426991
745426991
```

자바스크립트와 다르게 엘릭서는 숫자 타입이 없습니다. 대신 정수와 부동 소수점 값에 대한 별도의 타입이 있습니다. C#과 다르게 더 많은 메모리를 사용하고 큰 값을 가지는 정수 타입 그룹(byte, short, int, long 등)은 없습니다. 엘릭서의 정수는 임의의 정수를 가질 수 있습니다. 가장 작은 값이나 가장 큰 값에 대한 개념이 없습니다. 엄청나게 큰 정수는 엘릭서에서 지정될 수 있습니다. 엘릭서가 정수를 저장할 메모리를 가지고 있는 한 그것을 저장할 수 있을 것입니다.

매우 큰 수로 작업하는 것이 작은 수보다 더 많은 메모리와 처리 시간이 필요하다고 생각했습니다. 하지만 IEx에서 매우 큰 수를 사용해본 경험상 제가 느낄 정도로 지연이 있지는 않았습니다. 프로세서가 동작하는 시간은 차이가 있겠지만, 인간이 그것을 느낄 순 없습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> big_integer = 2409045930580398034859043850983827847329987883234
2409045930580398034859043850983827847329987883234
iex> another_big_integer = 8245789239840280948509343533503938584234
8245789239840280948509343533503938584234
iex> big_integer * another_big_integer
19864485012660862539728121685875365511253137949455637945916932944539055016611316465332756
```

숫자를 읽기 쉽게 하려면 밑줄을 이용하여 숫자를 그룹화할 수 있습니다. 이것은 오직 숫자를 인간이 읽기 쉽도록 해주는 것이며 컴파일러에는 아무런 의미가 없습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> big_integer = 34_453_234_984
34453234984
```

밑줄은 원하는 모든 곳에 두어 숫자를 그룹화 할 수 있습니다. 엘릭서는 신경 쓰지 않습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> big_integer = 45_4354_234_3
4543542343
```

밑줄은 정숫값의 한 부분으로 저장되지 않습니다. IEx는 밑줄 없이 값을 출력합니다.

엘릭서에는 값이 정수인지 확인할 수 있는 `is_integer` 함수가 있습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> is_integer(445)
true
iex> is_integer("445")
false
iex> is_integer(true)
false

```

## 실수

엘릭서에서 부동 소수점 수는 부동 소수점 데이터 타입을 나타냅니다. float는 C#의 double과 같은 IEEE 배정밀도 부동 소수점 값입니다. float 리터럴은 C#이나 자바스크립트에서 지정하는 것과 같이 십진수 부분이 있는 숫자입니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> decimal_number = 3.141
3.141
iex> decimal_number = -0.453434
-0.453434
iex> decimal_number = 1.0
1.0
```

실수는 다른 언어에서 구현된 것과 마찬가지로 단지 배정밀도 부동 소수점입니다. 그래서 그것의 정밀도가 무한하지 않고 정수 데이터 타입처럼 무한한 숫자를 저장할 수 없습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
decimal_number = 23434242354576575634523249854.453878983947548738940835
2.3434242354576578e28
```

모든 부동 소수점 수가 일반적으로 그렇듯이 소수점 값이 가끔 약간 부정확할 수 있습니다.

아래의 뺄셈은 -0.01이어야 하지만 부동 소수점 수 특성으로 인해 약간 어긋나게 됩니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> 86.24 - 86.25
-0.010000000000005116
```

절대 돈 관련해서는 부동 소수점 수를 사용하지 마세요. 저는 엘릭서가 C#처럼 고정 소수점 타입이 있었으면 좋겠습니다. 그것을 가능하게 해주는 엘릭서 라이브러리가 있길 바랍니다. 값이 부동 소수인지 확인하는 `is_float` 함수도 있습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> is_float(3.14)
true
iex> is_float(1)
false
iex> is_float(1.0)
true
iex> is_float("Bob")
false
```

## 아톰

아톰은 제가 엘릭서에서 가장 이해하기 어려운 자료형이었습니다. 왜냐하면 복잡한 개념도 아니고 단지 제가 전에 본 어떤 것보다도 달랐습니다. 아톰을 어떻게 사용하는지 감각을 익히기 위해서는 많은 시간과 예제가 필요합니다. 루비에는 비슷한 것이 있어서 조금 괜찮아야 하지만, 저는 이전에 비슷한 것을 본 적이 없습니다. 자바스크립트(ES6 이후)의 심볼은 가끔 아톰과 비슷하지만, 아톰과 같지는 않습니다. 제가 제대로 된 설명을 하기까지는 조금 시간이 걸렸습니다.

엘릭서는 아톰을 "그 값 자체가 이름인 상수"로 정의합니다. 이 정의는 저도 처음 봤을 때 헷갈렸고, 정확한 의미를 전달하지 않아서 다른 용어로 설명해보겠습니다. 아톰은 고유한 값으로 데이터 구조의 키, 결과 코드, 그 밖에도 고유한 값이 유용하게 사용되는 어느 곳에서든 사용됩니다.

아톰 리터럴은 콜론(:)으로 시작하고 그다음에 텍스트가 옵니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> result = :ok
:ok
iex> result = :error
:error
iex> key = :name
:name
iex> key = :age
:age
iex> long_atom = :this_is_a_long_atom
:this_is_a_long_atom
```

아톰은 짧으며 다른 값이랑 겹치지 않는 고유한 값을 나타냅니다. 아톰은 생성되면 모종의 엘릭서 아톰 테이블에 저장되고 그대로 유지됩니다. 이는 아톰을 지나치게 자주 생성하거나, 동적 데이터에서 아톰을 로드하면 절대 안 된다는 것을 뜻합니다.

고유한 값인 아톰은 오직 자기 자신과만 같다고 판단합니다. 따라서 `:ok`는 오직 `:ok`와 같고, `:name`은 오직 `:name`과 같습니다.

아톰은 런타임 환경에서 고유합니다. 이것은 엘릭서 프로세스의  아톰 `:message`가 다른 프로세스와도 같은 값을 갖는다는 것을 의미합니다. 이것은 프로세스 간 통신에 있어서 좋은 점 입니다.

아톰을 처음 접했을 때 저는 "왜 아톰을 쓰지? 문자열을 사용하면 안 되나?"라는 질문이 있었습니다. 즉시 알기는 어려웠고, 왜 그렇게 되는지 알아봐야 했습니다.

먼저 아톰은 문자열보다 효율적입니다. 엘릭서에서는 아톰을 내부적으로 정수에 매핑하기 때문에, 비교가 굉장히 효율적입니다. 두 번째로 엘릭서에서는 다른 목적으로 사용되는 문자열이 아톰으로 사용되지 않기 위해서 아톰을 확실하게 다른 타입으로 두려고 합니다. 다른 이점으로는 아톰이 문자열보다 분산 시스템에서 효율적입니다. 엘릭서에서 대부분 데이터는 생성된 프로세스에 의해 할당되지만, 아톰은 전체 가상 머신에 글로벌하게 적용됩니다. 다른 머신에 보내진 아톰은 해당 머신에서도 글로벌하게 생성됩니다.

얼랭 VM도 아톰의 개념을 가지고 있으며, 이것은 동시성에서 필수적인 역할을 합니다. 그래서 엘릭서에서도 아톰을 갖는 것이 타당합니다.

C#이나 C++(아마도 자바도)을 잘 안다면, 아톰과 enum의 유사성을 알 수 있을 것입니다. 그것들은 원시 데이터 타입(일반적으로 Int)에 매핑되며 각 열거형 값은 코드에서 고유합니다. C++는 실제로 기본 데이터 타입처럼 공개적으로 취급하지만, C#은 자체 데이터 타입으로 간주합니다. 그러나 아톰은 모두 같은 데이터 타입(아톰)이며 열거형 데이터 타입이 아닙니다. 또한 어떤 식으로든 네임스페이스가 되어있지 않도록 설계되어있습니다. 엘릭서는 추가 작업 없이 분산 시스템의 모든 부분에서 사용할 수 있기를 원합니다.

한 번 생성된 아톰은 절대 없어지지 않으며 얼랭VM의 아톰 테이블에는 1,048,576개만 저장할 수 있습니다. 아톰이 의도한 대로 사용되고 있다면 소스 코드에 정의된 아톰에 대해서는 충분한 공간입니다.

제가 아톰에 대해 읽은 자료에서는 외부 데이터가 데이터 구조에 로드되는 것에서 아톰을 동적으로 생성하지 말라고 강력하게 말합니다. 예를 들어 파일이나 네트워크에서 로드하여 키-밸류 값의 데이터를 생성할 수 있습니다. 그것은 엘릭서 소스 코드에서는 일반적인 방식이지만, 소스 코드에서 아톰 생성은 일반적으로 매우 작은 규모로 일어납니다. 외부 데이터에서 로드하는 경우 할당된 아톰의 수가 빠르게 증가할 수 있습니다.

JSON을 로드하는 경우 예를 들어 JSON 객체의 키에 따라 많은 아톰이 생성될 수 있습니다. VM이 실행 중일 때 그 아톰들은 절대 해제되지 않으며, 시스템의 수명 동안 JSON을 반복적으로 로드할 경우 아톰이 고갈되는 것을 경험할 수 있습니다. 아톰 저장 공간이 고갈되면 무슨 일이 일어나는지는 잘 모르지만, VM 전체에 안 좋은 영향을 줄 것으로 생각됩니다. 그래서 대신에 키를 문자열로 저장하는 것을 권장합니다. 문자열은 가비지 컬렉터에 의해 정리됩니다.

아톰은 오직 소스 코드에서 정의하고 사용하는 것으로 생성되어야 합니다.

아톰은 데이터 구조의 키를 표현하는 것뿐만 아니라 함수에서 반환되는 결과 코드와 같은 고윳값으로도 주로 사용합니다. 엘릭서에서는 어떤 함수(보통 외부 자원에 접근하는)가 아톰(`:ok` 또는 `:error`)과 실행 결과를 함께 반환하는 것이 일반적입니다.
