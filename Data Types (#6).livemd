# Data Types (#6)

## 도입부

대부분의 언어처럼 엘릭서도 데이터 타입이 있습니다. 그렇게 많지는 않습니다. 더 간단한 데이터 타입을 즉시 활용할 수 있지만, 복잡한 데이터 타입은 나중에 그것들의 문서가 필요합니다.

## 기본 타입

이 데이터 타입들은 제가 기본 데이터 타입이라고 부르는 것입니다. 저만의 용어이며 엘릭서의 용어가 아닙니다.

### 정수

엘릭서에서 정수는 다른 언어의 정수와 유사합니다. 소수점이 없는 정수입니다. 정수 리터럴은 단지 숫자라는 점에서 제가 본 모든 언어의 거의 유사합니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> integer1 = 300
300
iex> integer2 = 4
4
iex> integer3 = -34
-34
iex> bigger_integer = 745426991
745426991
```

자바스크립트와 다르게 엘릭서는 숫자 타입이 없습니다. 대신 정수와 부동 소수점 값에 대한 별도의 타입이 있습니다. C#과 다르게 더 많은 메모리를 사용하고 큰 값을 가지는 정수 타입 그룹(byte, short, int, long 등)은 없습니다. 엘릭서의 정수는 임의의 정수를 가질 수 있습니다. 가장 작은 값이나 가장 큰 값에 대한 개념이 없습니다. 엄청나게 큰 정수는 엘릭서에서 지정될 수 있습니다. 엘릭서가 정수를 저장할 메모리를 가지고 있는 한 그것을 저장할 수 있을 것입니다.

매우 큰 수로 작업하는 것이 작은 수보다 더 많은 메모리와 처리 시간이 필요하다고 생각했습니다. 하지만 IEx에서 매우 큰 수를 사용해본 경험상 제가 느낄 정도로 지연이 있지는 않았습니다. 프로세서가 동작하는 시간은 차이가 있겠지만, 인간이 그것을 느낄 순 없습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> big_integer = 2409045930580398034859043850983827847329987883234
2409045930580398034859043850983827847329987883234
iex> another_big_integer = 8245789239840280948509343533503938584234
8245789239840280948509343533503938584234
iex> big_integer * another_big_integer
19864485012660862539728121685875365511253137949455637945916932944539055016611316465332756
```

숫자를 읽기 쉽게 하려면 밑줄을 이용하여 숫자를 그룹화할 수 있습니다. 이것은 오직 숫자를 인간이 읽기 쉽도록 해주는 것이며 컴파일러에는 아무런 의미가 없습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> big_integer = 34_453_234_984
34453234984
```

밑줄은 원하는 모든 곳에 두어 숫자를 그룹화 할 수 있습니다. 엘릭서는 신경 쓰지 않습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> big_integer = 45_4354_234_3
4543542343
```

밑줄은 정숫값의 한 부분으로 저장되지 않습니다. IEx는 밑줄 없이 값을 출력합니다.

엘릭서에는 값이 정수인지 확인할 수 있는 `is_integer` 함수가 있습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> is_integer(445)
true
iex> is_integer("445")
false
iex> is_integer(true)
false

```

## 실수

엘릭서에서 부동 소수점 수는 부동 소수점 데이터 타입을 나타냅니다. float는 C#의 double과 같은 IEEE 배정밀도 부동 소수점 값입니다. float 리터럴은 C#이나 자바스크립트에서 지정하는 것과 같이 십진수 부분이 있는 숫자입니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> decimal_number = 3.141
3.141
iex> decimal_number = -0.453434
-0.453434
iex> decimal_number = 1.0
1.0
```

실수는 다른 언어에서 구현된 것과 마찬가지로 단지 배정밀도 부동 소수점입니다. 그래서 그것의 정밀도가 무한하지 않고 정수 데이터 타입처럼 무한한 숫자를 저장할 수 없습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
decimal_number = 23434242354576575634523249854.453878983947548738940835
2.3434242354576578e28
```

모든 부동 소수점 수가 일반적으로 그렇듯이 소수점 값이 가끔 약간 부정확할 수 있습니다.

아래의 뺄셈은 -0.01이어야 하지만 부동 소수점 수 특성으로 인해 약간 어긋나게 됩니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> 86.24 - 86.25
-0.010000000000005116
```

절대 돈 관련해서는 부동 소수점 수를 사용하지 마세요. 저는 엘릭서가 C#처럼 고정 소수점 타입이 있었으면 좋겠습니다. 그것을 가능하게 해주는 엘릭서 라이브러리가 있길 바랍니다. 값이 부동 소수인지 확인하는 `is_float` 함수도 있습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> is_float(3.14)
true
iex> is_float(1)
false
iex> is_float(1.0)
true
iex> is_float("Bob")
false
```

## 아톰
