# Diving into Elixir (#5)

## 도입부

이제 드디어 엘릭서에 대한 이야기를 끝내고 실제로 사용할 때입니다. 간단한 것이긴 하지만 오늘 우리는 실제로 엘릭서 코드를 작성해 볼 것입니다. 시작해봅시다!

## IEx

우리가 언어를 배우기 위해 사용할 첫 도구는 IEx입니다. 이것은 엘릭서의 대화형 프로그래밍 쉘입니다. 저는 IEx가 "**I**nteractive **E**li**x**ir"의 줄임말이라고 생각합니다. 이 환경에서는 엘릭서의 구문과 표현식을 즉시 평가하고 사용자에게 즉각적인 피드백을 줍니다. 자바스크립트나 비슷한 도구가 있는 다른 언어에 익숙한 사람들은 이것을 REPL(**R**ead-**E**valuate-**P**rint-**L**oop)로 알고 있을 것입니다.

이 환상적인 도구는 엘릭서를 배우는 것뿐만 아니라 실제 코드에서 사용하기 전에 대화형 환경에서 엘릭서 코드를 실행해 볼 수 있도록 해줍니다. 어떤 엘릭서 코드던지 이 환경에 올릴 수 있고 함수를 호출하면 어떤 일이 일어나는지 볼 수도 있습니다. 디버깅 기능에는 어떤 제한이 있다고 들었지만, 그 기능을 사용할 정도로 발전하려면 시간이 걸릴 것 같습니다.

## Digression 시간

만약 다른 많은 언어의 REPL(혹은 REPL과 유사한 환경)을 보려면 [repl.it](https://replit.com/)를 방문하십시오. 자바스크립트(브라우저), 자바스크립트(Node.js), 파이썬, 루비, 클로저, C#, 자바 등의 언어를 위한 대화형 환경이 있습니다. 확실하게 확인하진 않았지만 C++ 환경도 있습니다. C++는 대부분의 정적 타입 언어처럼 인터프리터가 아닌 컴파일이 되는 경향이 있기 때문에 REPL과 유사한 것이 없습니다.

[Repl.it](https://replit.com/)은 루비 온 레일즈, 리액트, 익스프레스, 제스트와 같은 몇몇 프레임워크를 위한 환경도 갖추고 있습니다. 코드를 작성하고 코드 조각을 만들고 또 링크로 공유할 수 있습니다. 저도 사용하곤 했습니다. 아쉽게도 엘릭서는 아직 없습니다. 꾸준히 언어가 추가되었기 때문에(자바스크립트로만 시작했습니다) 언젠가 엘릭서가 들어가 있기를 바랍니다.

커맨드 라인에서 "iex"라고 입력하여 IEx를 실행할 수 있으며, 엘릭서가 잘 설치되었다면 엘릭서 대화형 환경을 사용할 수 있습니다.

```shell
chipmunk:lwmelixir Kevin$ iex
Erlang/OTP 21 [erts-10.0.8] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace]

Interactive Elixir (1.7.3) - press Ctrl+C to exit (type h() ENTER for help)
iex> 
```

엘릭서 구문과 표현식을 입력할 수 있고 그것들이 평가된 결과를 볼 수 있습니다. 곧 같이해 볼 것입니다. 이 환경을 종료하려면 Ctrl+C를 두 번 누르면 됩니다. 종료하는 방법이 약간 어색하지만, 그것이 일반적인 방법입니다.

## 변수

변수에 값을 할당하는 사소한 작업부터 시작해보겠습니다. IEx를 켜고 변수에 무언가를 할당합니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> number = 10
10
iex> name = "Aethelstan"
"Aethelstan"
```

첫 번째 구문에서는 정수 `10`을 변수 `number`에 할당하고 두 번째 구문에서는 문자열 `"Aethelstan"`를 변수 `name`에 할당합니다. 이것은 다른 언어의 할당과 매우 유사합니다.

할당 구문으로 인한 IEx의 출력이 변수에 할당된 데이터와 같다는 것을 알 수 있습니다. 또한 변수 이름만 입력해도 데이터를 볼 수 있습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> number
10
iex> age
** (CompileError) iex:4: undefined function age/0

iex>
```

변수 `number`를 입력하면, IEx에서는 현재 `number`의 값을 보여줍니다. 존재하지 않는 변수 `age`를 입력하면, 에러가 납니다. IEx는 에러를 보여주고 다시 프롬프트로 돌아갑니다. 이 경우, 엘릭서는 `age`라는 이름을 가진 어떤 것도 찾을 수 없었고, 함수를 참조하려 한다고 생각했습니다.

여러 정적 타입 언어에서 변수는 항상 값을 가진 메모리 일부를 나타냅니다. 값을 할당할 때, 해당 메모리는 값으로 덮어 씌여집니다. 동적 타입 언어(적어도 제가 사용한 언어)에서 변수는 특정한 메모리를 식별하지 않습니다. 그것은 단지 특정한 데이터와 연관된 기호일 뿐입니다. 엘릭서도 그렇습니다.

실제로 엘릭서에서는 변수에 값을 할당하는 것을 "바인딩"이라고 합니다. 위 예제에서 변수 `number`는 값 10이 바인딩 되어있습니다. 아래처럼 다른 값으로 다시 바인딩할 수 있습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> number = 10
10
iex> number = 4
4
```

변수 `number`는 다른 데이터를 참조하도록 변경되었습니다. 엘릭서는 불변형 데이터만 가지고 있으므로, 이 원리는 모든 데이터 타입에 적용됩니다. 심볼은 재 바인딩 될 수 있지만 데이터 자체는 수정되지 않습니다.

엘릭서는 동적 타입 언어이기 때문에 정적 타입 언어처럼 변수를 특정 데이터 타입과 연관 지을 필요가 없습니다. 어떤 데이터 타입도 변수에 바인드 할 수 있습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> number = 5
5
iex> number = "five"
"five"
```

또한 리터럴 값도 유효한 표현식이므로 IEx에 입력할 수 있습니다. IEx는 표현식을 평가하고 결과를 보여줄 것입니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> "This is a string value"
"This is a string value"
```

리터럴을 출력하는 것은 그다지 유용하진 않지만, 엘릭서가 표현식으로부터 어떻게 값을 도출해내는지 보여주는 데 도움이 됩니다.

## 구문

엘릭서의 구문은 C 기반 언어의 세미콜론(;)과 같은 종료 문자로 끝나지 않습니다. 자바스크립트는 세미콜론과 같은 종료 문자를 가질 수 있지만 선택 사항입니다. 대부분은(몇 가지 예외가 있지만) 자바스크립트에서 세미콜론을 사용하지 않아도 구문이 어디서 끝나는지 파악할 수 있습니다.

엘릭서는 라인의 끝에 도달하면 구문이 끝나는지 혹은 다음 라인을 읽으려 하는지 알 수 있을 것입니다. 구문 종결 문자가 있는 언어는 모호하지 않은 것으로 알고 있습니다. 엘릭서는 어떻게 되는지 잘 모르지만 틀림없이 어딘가는 문법 규칙이 있을 것입니다.

그럼에도 불구하고 엘릭서에서는 같은 라인에 여러 개의 구문을 입력할 수 있습니다. 그 경우 종료 문자(세미콜론)가 필요하지만, 그것은 엘릭서에게 문법상의 실수를 만들지 않도록 두 개 이상의 문을 사용하고 있다는 것을 알려주는 것입니다. 저는 같은 라인에 여러 구문이 있는 것을 좋아하지 않습니다. 각각의 구문이 라인마다 있는 것을 선호합니다.

이 예제에서 볼 수 있듯이 다중 구문 라인의 값은 마지막 구문의 값이 평가됩니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> number = 10 ; name = "Bob"
"Bob"
```
