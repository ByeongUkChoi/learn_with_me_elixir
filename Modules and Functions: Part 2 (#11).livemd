# Modules and Functions: Part 2 (#11)

## 도입부

> 엘릭서 모듈과 함수에 대해 자세히 알아봅시다. 중요한 주제이므로 다뤄야 합니다.

이 주제의 1부에서는 모듈, 함수 그리고 그것을 호출하는 방법에 대해 소개했습니다. 엘릭서의 함수에 관해 이야기할 내용이 많으니 계속 이어 나가겠습니다.

## 디폴트 매개변수 값

엘릭서 함수 매개변수는 각 매개변수 뒤에 `\\`를 사용하여 기본값을 지정할 수 있습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
def do_something(item, count \\ 1)
```

따라서 위 함수에서 함수를 호출할 때 `count` 매개변수를 지정하지 않으면 `count` 매개변수는 기본값 1이 됩니다. 즉 `do_something("Bob")`을 호출하면 `count`는 기본값 1이 되고 `do_something("Bob", 4)`를 호출하면 `count`는 4의 값을 가지게 됩니다.

엘릭서는 기본값을 가질 때 실제로 여러 함수를 정의합니다. 이 경우 `do_something/1`과 `do_something/2`를 생성합니다. 애리티가 1인 함수는 기본값을 전달하여 애리티가 2인 함수를 호출합니다.

매개변수 기본값에 대해 배울 때 찾은 정보는 이것뿐이었기 때문에 기본값이 자바스크립트나 C#과 어떻게 다른지 알아보기 시작했습니다.

자바스크립트에서 모든 매개변수는 선택 사항입니다. 매개변수에 기본값을 지정하는 경우(ES6 이상)와 호출자가 기본값을 지정하지 않은 경우 해당 매개변수에 기본값이 할당됩니다. 그렇지 않은 경우 해당 매개변수는 `undefined`를 가져옵니다.

다음 자바스크립트 함수를 살펴보겠습니다.

```javascript
function do_something(a, b = 1, c, d) {
  return [a, b, c, d];
}
```

`do_something("Bob")`을 호출하면 `["Bob", 1, undefined, undefined]`이 반환됩니다. 기본값도 없고 호출자가 값을 제공하지 않은 매개변수는 기본값이 `undefined`로 설정됩니다.

반면에 C#에서는 기본값이 있는 모든 매개변수는 맨 끝에 있어야 합니다. C#에서 기본값이 있는 옵셔널한 매개변수는 필수 매개변수(기본값이 없는 매개변수)보다 앞에 올 수 없습니다.

따라서 다음 예제에서는 컴파일 오류가 발생합니다.

```cs
public List<int> DoSomething(int a, int b = 1, int c, int d)
{
	return new List<int> {a, b, c, d};
}
```

기본값을 끝으로 이동시키면 코드가 컴파일될 수 있습니다.

```cs
public List<int> DoSomething(int a, int b, int c, int d = 1)
{
	return new List<int> {a, b, c, d};
}
```

30초 가량 검색해도 이 상황에서 엘릭서가 어떻게 동작하는지 알 수 없었기 때문에 이를 확인하기 위해 직접 사용해 보기로 했습니다. 엘릭서는 제가 예상한 대로 동작하지 않았습니다.

엘릭서에서 다음 함수를 만들었습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
def create_list(a, b \\ 1, c, d) do
	[a, b, c, d]
end
```

그런 다음 세 개의 매개변수를 사용하여 호출했습니다. 처음 세 개(a, b, c)를 채운 다음 d에 대한 값이 없어서 오류가 발생할 것으로 예상했지만, 다음과 같이 나왔습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> DefaultValues.create_list("Bob", 4, 3)
{"Bob", 1, 4, 3}
iex> DefaultValues.create_list("Bob", :ok, 4, 3)
{"Bob", :ok, 4, 3}
```

엘릭서가 `do_something/3` 함수와 `do_something/4` 함수를 생성한 것으로 나타났습니다. `do_something/3` 함수는 필요한 매개변수만 가져와서 두 번째 매개변수를 기본값으로 하고 `do_something/4` 함수를 호출했습니다. 매우 흥미로웠습니다. 매개변수의 아무 곳에나 기본값을 넣은 다음 매개변수의 위치와 관계없이 필요한 매개변수만 전달할 수 있는 효과가 있습니다. 필수 매개변수가 먼저 채워집니다.

엘릭서가 기본값을 가지고 호출하는 대체 함수를 생성한다는 사실을 알고 나니 이해가 됩니다. 선택적 매개변수가 어디에 있는지는 상관없습니다.

## 비공개 함수

접근 제한 함수는 모듈 내에서만 볼 수 있는 모듈의 함수입니다. 모듈 외부에서 참조하거나 호출할 수 없습니다. 공개 함수는 `def` 키워드를 사용하여 정의하는 반면, 비공개 함수는 `defp` 키워드를 사용하여 정의합니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule ExampleModule do
	defp private_function(value) do
		
	end
end
```

## 함수와 모듈 명명 규칙

함수와 모듈에는 모든 엘릭서 개발자가 사용하는 명명 규칙이 있습니다. 이러한 규칙을 벗어난다고 해서 엘릭서가 망가지진 않지만 다른 엘릭서 개발자가 코드를 읽고 이해하기는 더 어려워질 수 있습니다.

변수와 마찬가지로 함수도 스네이크 케이스입니다. `do_something_unexpected`와 같이 단어 사이에 밑줄이 있는 소문자를 사용하여 지정합니다.

변수와 마찬가지로 밑줄(_)로 시작하는 함수 이름은 함수를 사용해서는 안 된다는 것을 나타냅니다. 함수를 비공개 함수로 정의하지 않고 이런 식으로 정의하는 이유는 잘 모르겠지만 제가 알지 못하는 사용 사례가 있을 것입니다. 아마도 특정 모듈은 사용할 수 있지만 (C++의 프랜드 개념과 비슷하게) 다른 모듈은 사용할 수 없도록 하기 위해 이런 식으로 정의한 것일까요? 이에 대한 예시와 그 이유를 알고 싶습니다.

일반적으로 불리언 값을 반환하는 함수 이름 끝에는 "?" 문자를 추가합니다. 예를 들어 `is_available?`가 있습니다. 가드 절에서 사용하는 함수는 예외입니다. 불리언 값을 반환하지만 함수 이름 끝에 "?"가 없습니다. 현재로써는 가드 절이 무엇인지 모르지만 앞으로 배워야할 부분입니다.

일반적으로 실패 시 예외를 발생시키는 함수 끝에는 "!" 문자가 추가됩니다. 엘릭서 I/O 라이브러리에서는 같은 함수의 실패 시 예외를 발생시키는 것과 발생시키지 않는 버전을 가지는 많은 함수가 있으며, 두 함수의 차이점은 함수 이름 끝에 "!" 문자가 있다는 점입니다.

예를들어 `File.write/3`와 `File.write!/3`가 있습니다.
