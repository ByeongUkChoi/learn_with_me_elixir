# Modules and Functions: Part 2 (#11)

## 도입부

> 엘릭서 모듈과 함수에 대해 자세히 알아봅시다. 중요한 주제이므로 다뤄야 합니다.

이 주제의 1부에서는 모듈, 함수 그리고 그것을 호출하는 방법에 대해 소개했습니다. 엘릭서의 함수에 관해 이야기할 내용이 많으니 계속 이어 나가겠습니다.

## 디폴트 매개변수 값

엘릭서 함수 매개변수는 각 매개변수 뒤에 `\\`를 사용하여 기본값을 지정할 수 있습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
def do_something(item, count \\ 1)
```

따라서 위 함수에서 함수를 호출할 때 `count` 매개변수를 지정하지 않으면 `count` 매개변수는 기본값 1이 됩니다. 즉 `do_something("Bob")`을 호출하면 `count`는 기본값 1이 되고 `do_something("Bob", 4)`를 호출하면 `count`는 4의 값을 가지게 됩니다.

엘릭서는 기본값을 가질 때 실제로 여러 함수를 정의합니다. 이 경우 `do_something/1`과 `do_something/2`를 생성합니다. 애리티가 1인 함수는 기본값을 전달하여 애리티가 2인 함수를 호출합니다.

매개변수 기본값에 대해 배울 때 찾은 정보는 이것뿐이었기 때문에 기본값이 자바스크립트나 C#과 어떻게 다른지 알아보기 시작했습니다.

자바스크립트에서 모든 매개변수는 선택 사항입니다. 매개변수에 기본값을 지정하는 경우(ES6 이상)와 호출자가 기본값을 지정하지 않은 경우 해당 매개변수에 기본값이 할당됩니다. 그렇지 않은 경우 해당 매개변수는 `undefined`를 가져옵니다.

다음 자바스크립트 함수를 살펴보겠습니다.

```javascript
function do_something(a, b = 1, c, d) {
  return [a, b, c, d];
}
```

`do_something("Bob")`을 호출하면 `["Bob", 1, undefined, undefined]`이 반환됩니다. 기본값도 없고 호출자가 값을 제공하지 않은 매개변수는 기본값이 `undefined`로 설정됩니다.

반면에 C#에서는 기본값이 있는 모든 매개변수는 맨 끝에 있어야 합니다. C#에서 기본값이 있는 옵셔널한 매개변수는 필수 매개변수(기본값이 없는 매개변수)보다 앞에 올 수 없습니다.

따라서 다음 예제에서는 컴파일 오류가 발생합니다.

```cs
public List<int> DoSomething(int a, int b = 1, int c, int d)
{
	return new List<int> {a, b, c, d};
}
```

기본값을 끝으로 이동시키면 코드가 컴파일될 수 있습니다.

```cs
public List<int> DoSomething(int a, int b, int c, int d = 1)
{
	return new List<int> {a, b, c, d};
}
```

30초 가량 검색해도 이 상황에서 엘릭서가 어떻게 동작하는지 알 수 없었기 때문에 이를 확인하기 위해 직접 사용해 보기로 했습니다. 엘릭서는 제가 예상한 대로 동작하지 않았습니다.

엘릭서에서 다음 함수를 만들었습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
def create_list(a, b \\ 1, c, d) do
	[a, b, c, d]
end
```

그런 다음 세 개의 매개변수를 사용하여 호출했습니다. 처음 세 개(a, b, c)를 채운 다음 d에 대한 값이 없어서 오류가 발생할 것으로 예상했지만, 다음과 같이 나왔습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> DefaultValues.create_list("Bob", 4, 3)
{"Bob", 1, 4, 3}
iex> DefaultValues.create_list("Bob", :ok, 4, 3)
{"Bob", :ok, 4, 3}
```

엘릭서가 `do_something/3` 함수와 `do_something/4` 함수를 생성한 것으로 나타났습니다. `do_something/3` 함수는 필요한 매개변수만 가져와서 두 번째 매개변수를 기본값으로 하고 `do_something/4` 함수를 호출했습니다. 매우 흥미로웠습니다. 매개변수의 아무 곳에나 기본값을 넣은 다음 매개변수의 위치와 관계없이 필요한 매개변수만 전달할 수 있는 효과가 있습니다. 필수 매개변수가 먼저 채워집니다.

엘릭서가 기본값을 가지고 호출하는 대체 함수를 생성한다는 사실을 알고 나니 이해가 됩니다. 선택적 매개변수가 어디에 있는지는 상관없습니다.

## 비공개 함수

접근 제한 함수는 모듈 내에서만 볼 수 있는 모듈의 함수입니다. 모듈 외부에서 참조하거나 호출할 수 없습니다. 공개 함수는 `def` 키워드를 사용하여 정의하는 반면, 비공개 함수는 `defp` 키워드를 사용하여 정의합니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule ExampleModule do
	defp private_function(value) do
		
	end
end
```

## 함수와 모듈 명명 규칙

함수와 모듈에는 모든 엘릭서 개발자가 사용하는 명명 규칙이 있습니다. 이러한 규칙을 벗어난다고 해서 엘릭서가 망가지진 않지만 다른 엘릭서 개발자가 코드를 읽고 이해하기는 더 어려워질 수 있습니다.

변수와 마찬가지로 함수도 스네이크 케이스입니다. `do_something_unexpected`와 같이 단어 사이에 밑줄이 있는 소문자를 사용하여 지정합니다.

변수와 마찬가지로 밑줄(_)로 시작하는 함수 이름은 함수를 사용해서는 안 된다는 것을 나타냅니다. 함수를 비공개 함수로 정의하지 않고 이런 식으로 정의하는 이유는 잘 모르겠지만 제가 알지 못하는 사용 사례가 있을 것입니다. 아마도 특정 모듈은 사용할 수 있지만 (C++의 프랜드 개념과 비슷하게) 다른 모듈은 사용할 수 없도록 하기 위해 이런 식으로 정의한 것일까요? 이에 대한 예시와 그 이유를 알고 싶습니다.

일반적으로 불리언 값을 반환하는 함수 이름 끝에는 "?" 문자를 추가합니다. 예를 들어 `is_available?`가 있습니다. 가드 절에서 사용하는 함수는 예외입니다. 불리언 값을 반환하지만 함수 이름 끝에 "?"가 없습니다. 현재로써는 가드 절이 무엇인지 모르지만 앞으로 배워야할 부분입니다.

일반적으로 실패 시 예외를 발생시키는 함수 끝에는 "!" 문자가 추가됩니다. 엘릭서 I/O 라이브러리에서는 같은 함수의 실패 시 예외를 발생시키는 것과 발생시키지 않는 버전을 가지는 많은 함수가 있으며, 두 함수의 차이점은 함수 이름 끝에 "!" 문자가 있다는 점입니다.

예를들어 `File.write/3`와 `File.write!/3`가 있습니다.

예외를 발생시키지 않는 함수는 일반적으로 결과(`:ok` 또는 `:error`)와 발생한 모든 데이터가 포함된 튜플을 반환합니다.

엘릭서 함수 이름이 "size"인 경우 해당 연산이 상수 시간(O(1))으로 실행됩니다. 이는 일반적으로 크기가 데이터 구조에 함께 저장되기 때문입니다.

엘릭서 함수 이름이 "length"인 경우 해당 연산이 선형 시간(O(n))으로 실행됩니다. 이는 일반적으로 데이터 항목의 개수를 파악하기 위해 알고리즘이 데이터 항목을 반복하기 때문입니다.

함수 *매개변수*가 사용되지 않을 경우 이름 앞에 밑줄이 표시됩니다. 함수의 여러 버전에서 매개변수가 한 버전에서는 사용되지만 다른 버전에서는 사용되지 않는 경우가 종종 있습니다. 밑줄은 코드를 읽는 사람에게 정보를 제공할 뿐만 아니라 함수의 파라미터를 사용하지 않았다고 경고를 내보내 컴파일을 억제합니다.

컴파일러가 사용되지 않은 매개변수를 감지할 때 발생하는 경고의 예입니다.

```
warning: variable "param2" is unused
iex:4
```

사용하지 않는 매개변수 앞에 밑줄을 넣으면 이 경고를 피할 수 있습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
def do_something(param1, _param2) do
	param1
end
```

모듈의 이름은 첫 글자가 대문자이고 모듈의 각 단어가 대문자로 시작하는 카멜 케이스를 사용하여 지정합니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule RoadSegment do

end
```

## 다른 모듈의 함수 사용

다른 모듈에서 함수를 호출하려면 "[모듈 이름].[함수 이름]"을 호출하면 됩니다.

다음은 `String` 모듈에서 `length` 함수를 호출하는 예제입니다. String 모듈은 엘릭서 표준 라이브러리의 일부이며, 모든 표준 라이브러리 모듈은 어디서나 사용할 수 있습니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> String.length("This is a string")
16
```

현재로서는 엘릭서가 참조한 모듈을 어떻게 찾는지 아직 명확하지 않습니다. 일종의 검색 경로가 있는지, 아니면 엘릭서 컴파일러에서 컴파일된 모든 모듈을 사용할 수 있을지 잘 모르겠습니다. 앞으로 더 명확해질 것으로 예상합니다.

## 전체 모듈 가져오기

모듈의 함수를 현재 네임스페이스로 가져오려면 `import` 키워드를 사용하면 됩니다. 다음 예제는 String 모듈의 모든 함수를 현재 네임스페이스로 가져오는 것입니다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> import String
String
iex> String.upcase("This is a string")
"THIS IS A STRING"
iex> upcase("This is a string")
"THIS IS A STRING"
```

함수를 가져오면 더 이상 모듈 이름을 지정할 필요가 없습니다. 함수 이름을 호출하기만 하면 됩니다.

모듈 이름을 지정하거나 아무것도 가져오지 않고도 엘릭서에서 사용할 수 있는 함수는 `Kernel` 모듈에 있습니다. `is_atom`이나 `div`와 같은 함수가 이에 해당합니다. 심지어 `+`,`-`,`&&` 또는 `===`와 같은 연산자도 실제로는 `Kernel` 모듈에 있는 함수입니다. 엘릭서 환경은 `Kernel`의 모든 함수를 동으로 가져오기 때문에 `Kernel.+` 또는 `Kernel.is_atom`을 지정하지 않고도 이러한 함수를 사용할 수 있습니다.

현재 네임스페이스로 가져온 모듈의 함수 이름이 다른 가져온 모듈의 함수와 충돌할 수 있으므로 주의해야 합니다.

예를 들어, `Kernel` 모듈에는 리스트의 길이를 결정하는 `length/1` 함수가 있습니다. 이 함수가 리스트 모듈에 없는 이유는 저에게 미스터리이지만, 그렇게 되어있습니다(문서에 따르면 가드 절에 사용할 수 있다고 나와 있는데, 그 이유가 무엇인지 궁금합니다). `String` 모듈에도 `length/1` 함수가 있습니다. String의 모든 함수를 가져와도 어떤 종류의 오류나 경고도 발생하지 않았지만, 현재 네임스페이스에 두 개의 `length/1` 함수가 있다는 것을 알게 되었습니다.

문자열에서 `length/1`을 호출하면 어떤 일이 발생하는지 살펴봅시다.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> import String
String
iex> length("This is a string")
** (CompileError) iex:7: function length/1 imported from both String and Kernel, call is ambiguous
    (elixir) src/elixir_dispatch.erl:111: :elixir_dispatch.expand_import/6
    (elixir) src/elixir_dispatch.erl:81: :elixir_dispatch.dispatch_import/5
iex> String.length("This is a string")
16
iex> Kernel.length([1, 2, 3])
3
```
